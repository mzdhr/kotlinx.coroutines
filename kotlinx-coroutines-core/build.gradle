/*
 * Copyright 2016-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license.
 */

apply plugin: 'kotlin-multiplatform'
apply from: rootProject.file("gradle/compile-jvm-multiplatform.gradle")
apply from: rootProject.file("gradle/compile-common.gradle")
apply from: rootProject.file("gradle/compile-js-multiplatform.gradle")
apply from: rootProject.file("gradle/compile-native-multiplatform.gradle")
apply from: rootProject.file('gradle/publish-npm-js.gradle')

project.ext.ideaActive = System.getProperty('idea.active') == 'true'
project.ext.sourceSetSuffixes = ["Main", "Test"]

void defineSourceSet(newName, dependsOn, includedInPred) {
    for (suffix in project.ext.sourceSetSuffixes) {
        def newSS = kotlin.sourceSets.maybeCreate(newName + suffix)
        for (dep in dependsOn) {
            newSS.dependsOn(kotlin.sourceSets[dep + suffix])
        }
        for (curSS in kotlin.sourceSets) {
            def curName = curSS.name
            if (curName.endsWith(suffix)) {
                def prefix = curName.substring(0, curName.length() - suffix.length())
                if (includedInPred(prefix)) curSS.dependsOn(newSS)
            }
        }
    }
}

boolean isNativeDarwin(String name) { return ["ios", "macos", "tvos", "watchos"].any { name.startsWith(it) } }
boolean isNativeOther(String name) { return ["linux", "mingw"].any { name.startsWith(it) } }

/* TARGETS:
     js -----------------------------------------------------+
                                                             |
                                                             V
     jvm -------------------------------> concurrent ---> common
                                              ^
     ios     \                                |
     macos   | ---> nativeDarwin ---> native --+
     tvos    |                         ^
     watchos /                         |
                                       |
     linux  \  ---> nativeOther -------+
     mingw  /
 */

defineSourceSet("concurrent", ["common"]) { it in ["jvm", "native"] }
defineSourceSet("nativeDarwin", ["native"]) { isNativeDarwin(it) }
defineSourceSet("nativeOther", ["native"]) { isNativeOther(it) }

/*
 * All platform plugins and configuration magic happens here instead of build.gradle
 * because JMV-only projects depend on core, thus core should always be initialized before configuration.
 */
kotlin {
    sourceSets {
        commonMain {
            dependencies {
                // todo: we should not need it
                // todo: it must be compileOnly or JVM is spoiled !!!
                implementation "org.jetbrains.kotlinx:atomicfu-common:$atomicfu_version"
            }
        }
    }

    configure(sourceSets) {
        def srcDir = name.endsWith('Main') ? 'src' : 'test'
        def platform = name[0..-5]
        kotlin.srcDirs = ["$platform/$srcDir"]
        if (name == "jvmMain") {
            resources.srcDirs = ["$platform/resources"]
        } else if (name == "jvmTest") {
            resources.srcDirs = ["$platform/test-resources"]
        }
        languageSettings {
            progressiveMode = true
            experimentalAnnotations.each { useExperimentalAnnotation(it) }
        }
    }

    configure(targets) {
        // "Main" native targets -- one for each OS
        if (["macos", "linux", "mingw"].any { name.startsWith(it) }) {
            binaries {
                // Test for memory leaks using a special entry point that does not exit but returns from main
                binaries.getTest("DEBUG").freeCompilerArgs += ["-e", "kotlinx.coroutines.mainNoExit"]
                // Configure a separate test where code runs in background
                test("background", [org.jetbrains.kotlin.gradle.plugin.mpp.NativeBuildType.DEBUG]) {
                    freeCompilerArgs += ["-e", "kotlinx.coroutines.mainBackground"]
                }
            }
            testRuns {
                background { setExecutionSourceFrom(binaries.backgroundDebugTest) }
            }
        }
    }

    configure(targets) {
        def targetName = it.name
        compilations.all { compilation ->
            def compileTask = tasks.getByName(compilation.compileKotlinTaskName)
            // binary compatibility support
            if (targetName.contains("jvm") && compilation.compilationName == "main") {
                compileTask.kotlinOptions.freeCompilerArgs += ["-Xdump-declarations-to=${buildDir}/visibilities.json"]
            }
        }
    }
}

configurations {
    configureKotlinJvmPlatform(kotlinCompilerPluginClasspath)
}

// Update module name for metadata artifact to avoid conflicts
// see https://github.com/Kotlin/kotlinx.coroutines/issues/1797
compileKotlinMetadata {
    kotlinOptions {
        freeCompilerArgs += ["-module-name", "kotlinx-coroutines-core-common"]
    }
}

def configureNativeSourceSetPreset(name, preset) {
    def hostMainCompilation = project.kotlin.targetFromPreset(preset).compilations.main
    def compileConfiguration = configurations[hostMainCompilation.compileDependencyConfigurationName]
    def hostNativePlatformLibs = files(provider {
        compileConfiguration.findAll {
            it.path.endsWith(".klib") || it.absolutePath.contains("klib${File.separator}platform")
        }
    })
    for (suffix in project.ext.sourceSetSuffixes) {
        configure(kotlin.sourceSets[name + suffix]) {
            dependencies.add(implementationMetadataConfigurationName, hostNativePlatformLibs)
        }
    }
}

// Configure platform libraries for native source sets when working in IDEA
if (project.ext.ideaActive) {
    def manager = project.ext.hostManager
    def linuxPreset = kotlin.presets.linuxX64
    def macosPreset = kotlin.presets.macosX64
    // linux should be always available (cross-compilation capable) -- use it as default
    assert manager.isEnabled(linuxPreset.konanTarget)
    // use macOS libs for nativeDarwin if available
    def macosAvailable = manager.isEnabled(macosPreset.konanTarget)
    // configure source sets
    configureNativeSourceSetPreset("native", linuxPreset)
    configureNativeSourceSetPreset("nativeOther", linuxPreset)
    configureNativeSourceSetPreset("nativeDarwin", macosAvailable ? macosPreset : linuxPreset)
}

kotlin.sourceSets {
    jvmTest.dependencies {
        api "org.jetbrains.kotlinx:lincheck:$lincheck_version"
        api "org.jetbrains.kotlinx:kotlinx-knit-test:$knit_version"
        api "com.esotericsoftware:kryo:4.0.0"
        implementation project (":android-unit-tests")
    }
}

task checkJdk16() {
    // only fail w/o JDK_16 when actually trying to compile, not during project setup phase
    doLast {
        if (!System.env.JDK_16) {
            throw new GradleException("JDK_16 environment variable is not defined. " +
                    "Can't build against JDK 1.6 runtime and run JDK 1.6 compatibility tests. " +
                    "Please ensure JDK 1.6 is installed and that JDK_16 points to it.")
        }
    }
}

tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile) {
    kotlinOptions.jdkHome = System.env.JDK_16
    // only fail when actually trying to compile, not during project setup phase
    dependsOn(checkJdk16)
}

jvmTest {
    minHeapSize = '1g'
    maxHeapSize = '1g'
    enableAssertions = true
    systemProperty 'java.security.manager', 'kotlinx.coroutines.TestSecurityManager'
    // 'stress' is required to be able to run all subpackage tests like ":jvmTests --tests "*channels*" -Pstress=true"
    if (!project.ext.ideaActive && rootProject.properties['stress'] == null) {
        exclude '**/*StressTest.*'
    }
    systemProperty 'kotlinx.coroutines.scheduler.keep.alive.sec', '100000' // any unpark problem hangs test
}

task jvmStressTest(type: Test, dependsOn: compileTestKotlinJvm) {
    classpath = files { jvmTest.classpath }
    testClassesDirs = files { jvmTest.testClassesDirs }
    minHeapSize = '1g'
    maxHeapSize = '1g'
    include '**/*StressTest.*'
    enableAssertions = true
    testLogging.showStandardStreams = true
    systemProperty 'kotlinx.coroutines.scheduler.keep.alive.sec', '100000' // any unpark problem hangs test
}

task jdk16Test(type: Test, dependsOn: [compileTestKotlinJvm, checkJdk16]) {
    classpath = files { jvmTest.classpath }
    testClassesDirs = files { jvmTest.testClassesDirs }
    executable = "$System.env.JDK_16/bin/java"
    exclude '**/*LFStressTest.*' // lock-freedom tests use LockFreedomTestEnvironment which needs JDK8
    exclude '**/*LCStressTest.*' // lin-check tests use LinChecker which needs JDK8
    exclude '**/exceptions/**'   // exceptions tests check suppressed exception which needs JDK8
    exclude '**/ExceptionsGuideTest.*'
}

// Run these tests only during nightly stress test
jdk16Test.onlyIf { project.properties['stressTest'] != null }

// Always run those tests
task moreTest(dependsOn: [jvmStressTest, jdk16Test])
build.dependsOn moreTest

task testsJar(type: Jar, dependsOn: jvmTestClasses) {
    classifier = 'tests'
    from compileTestKotlinJvm.destinationDir
}

artifacts {
    archives testsJar
}

// KT-37264 Workaround for metadata compilation problem (provide an empty metadata instead)
afterEvaluate {
    def emptySrcDir = new File(buildDir, "tmp/emptySrc")
    emptySrcDir.mkdirs()
    def emptySrcFile = new File(emptySrcDir, "EmptyKtFile.kt")
    emptySrcFile.createNewFile()
    def emptySrcDirs = project.objects.sourceDirectorySet("emptySrc", "empty sources for Kotlin common compilations")
    emptySrcDirs.srcDir(emptySrcDir)
    tasks.matching { it.name == "compileConcurrentMainKotlinMetadata" }.all {
        doFirst {
            emptySrcFile.text = "package kotlinx.coroutines"
            source = fileTree(emptySrcDir)
        }
    }
    kotlin.metadata { }.compilations.matching { it.name in ["nativeMain", "nativeDarwinMain", "nativeOtherMain"] }.all {
        it.getAllSources$kotlin_gradle_plugin().clear()
        it.getAllSources$kotlin_gradle_plugin().add(emptySrcDirs)
    }
}